<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>three.js hero</title>
  <style>
    html,body { height:100%; margin:0; background:#000; }
    #hero { height:100vh; position:relative; overflow:hidden; }
    #webgl { position:absolute; inset:0; width:100%; height:100%; display:block; }
    h1 {
      position:absolute; left:8%; bottom:12%; margin:0;
      font:700 clamp(28px, 6vw, 96px)/1 system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, 'Noto Sans JP', sans-serif;
      color:#e8ecff; letter-spacing:.02em; z-index:2;
      mix-blend-mode:screen;
    }
  </style>
</head>
<body>
  <section id="hero">
    <canvas id="webgl"></canvas>
    <h1>Your Brand</h1>
  </section>

  <!-- three.js: ESM（モジュール）でCDNから読み込み。存在する安定版に固定 -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.164.0/build/three.module.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.164.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.164.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.164.0/examples/jsm/postprocessing/UnrealBloomPass.js';

    const canvas = document.getElementById('webgl');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0,0,6);

    // 環境
    scene.add(new THREE.HemisphereLight(0xffffff, 0x202040, 0.9));
    const dir = new THREE.DirectionalLight(0xffffff, 0.5);
    dir.position.set(3,3,3);
    scene.add(dir);

    // 粒子
    const COUNT = 3200;
    const g = new THREE.BufferGeometry();
    const pos = new Float32Array(COUNT*3);
    for (let i=0;i<COUNT;i++){
      pos[i*3+0]=(Math.random()-0.5)*12;
      pos[i*3+1]=(Math.random()-0.5)*8;
      pos[i*3+2]=(Math.random()-0.5)*10;
    }
    g.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const points = new THREE.Points(
      g,
      new THREE.PointsMaterial({ color:0x66ccff, size:0.05, transparent:true, opacity:0.9 })
    );
    scene.add(points);

    // 中央の“ガラス板”風
    const plate = new THREE.Mesh(
      new THREE.PlaneGeometry(3.2,1.8,32,32),
      new THREE.MeshPhysicalMaterial({
        color:0xffffff, metalness:0, roughness:0.08,
        transmission:0.72, thickness:0.4, transparent:true
      })
    );
    plate.position.z = -0.5;
    scene.add(plate);

    // Bloom
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.5, 0.85, 0.8);
    composer.addPass(bloom);

    // パララックス
    const mouse = {x:0, y:0};
    addEventListener('pointermove', e=>{
      mouse.x = (e.clientX / innerWidth) - 0.5;
      mouse.y = (e.clientY / innerHeight) - 0.5;
    });

    // ループ
    const clock = new THREE.Clock();
    function tick(){
      const dt = clock.getDelta();
      points.rotation.y += dt * 0.05;

      const p = points.geometry.attributes.position;
      for (let i=0;i<p.count;i++){
        const iz = i*3+2, iy = i*3+1;
        const z = p.array[iz];
        p.array[iy] += Math.sin(clock.elapsedTime*0.6 + z) * 0.0006;
      }
      p.needsUpdate = true;

      camera.position.x += (mouse.x*0.8 - camera.position.x)*0.05;
      camera.position.y += (-mouse.y*0.6 - camera.position.y)*0.05;
      camera.lookAt(0,0,0);

      composer.render();
      requestAnimationFrame(tick);
    }
    tick();

    // リサイズ
    addEventListener('resize', ()=>{
      const w=innerWidth, h=innerHeight;
      renderer.setSize(w,h);
      composer.setSize(w,h);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
